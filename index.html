<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Carte Signalements - Ille-et-Vilaine</title>
    <script src="https://grist.numerique.gouv.fr/grist-plugin-api.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <style>
        /* ... ton CSS inchang√© ... */
    </style>
</head>
<body>
    <div id="banner" class="instruction-banner">
        üîµ Cliquez pour marquer le D√âBUT du tron√ßon coup√©
    </div>
    <button id="geolocateBtn" class="geolocate-btn" title="Me localiser">üìç</button>
    <div id="map"></div>

    <script>
        // --- [code inchang√© jusqu‚Äô√† displayExistingMarkers()] ---

        function displayExistingMarkers(records) {
            existingMarkers.forEach(marker => map.removeLayer(marker));
            existingMarkers = [];
            existingLines.forEach(line => map.removeLayer(line));
            existingLines = [];

            records.forEach(record => {
                const fields = record.fields;
                if (!fields.Latitude || !fields.Longitude) return;
                if (typeof fields.Latitude !== 'number' || typeof fields.Longitude !== 'number') return;

                const color = PRIORITY_COLORS[fields.Priorite] || '#6c757d';
                const causes = Array.isArray(fields.Cause) ? fields.Cause.join(', ') : fields.Cause;

                // ‚úÖ Correction affichage date (timestamp ‚Üí millisecondes)
                let dateValue = fields.Date_heure;
                if (typeof dateValue === 'number' && dateValue < 1e12) {
                    dateValue = dateValue * 1000;
                }
                const dateStr = new Date(dateValue).toLocaleString('fr-FR');

                const popupContent = `
                    <div style="min-width: 200px;">
                        <h3 style="margin: 0 0 10px 0; color: #333; font-size: 15px;">
                            ${fields.Route} - ${fields.Commune}
                        </h3>
                        <div style="font-size: 13px;">
                            <p style="margin: 5px 0;"><strong>Type:</strong> ${fields.Type_coupure}</p>
                            <p style="margin: 5px 0;"><strong>Priorit√©:</strong> 
                                <span style="color: ${color}; font-weight: 600;">${fields.Priorite}</span>
                            </p>
                            <p style="margin: 5px 0;"><strong>Cause(s):</strong> ${causes}</p>
                            <p style="margin: 5px 0;"><strong>Agent:</strong> ${fields.Agent}</p>
                            <p style="margin: 5px 0;"><strong>Statut:</strong> 
                                <span style="padding: 2px 6px; border-radius: 3px; font-size: 11px; 
                                    background: ${fields.Statut === 'Actif' ? '#fee' : '#efe'}; 
                                    color: ${fields.Statut === 'Actif' ? '#c00' : '#080'};">
                                    ${fields.Statut}
                                </span>
                            </p>
                            ${fields.Description ? `<p style="margin: 5px 0;"><strong>Description:</strong><br>${fields.Description}</p>` : ''}
                            <p style="margin: 5px 0; font-size: 11px; color: #999;">${dateStr}</p>
                        </div>
                    </div>
                `;

                // reste du code inchang√© (cr√©ation marqueurs ou lignes)
                const isTroncon = fields.Latitude_fin && fields.Longitude_fin &&
                                  typeof fields.Latitude_fin === 'number' &&
                                  typeof fields.Longitude_fin === 'number';
                if (isTroncon) {
                    const line = L.polyline(
                        [[fields.Latitude, fields.Longitude], [fields.Latitude_fin, fields.Longitude_fin]], 
                        { color: color, weight: 6, opacity: fields.Statut === 'Resolu' ? 0.4 : 0.8 }
                    ).bindPopup(popupContent).bindTooltip(`${fields.Route} - ${fields.Priorite}`, { direction: 'center' }).addTo(map);
                    existingLines.push(line);
                } else {
                    const icon = L.divIcon({
                        className: 'existing-marker',
                        html: `<div style="background:${color};width:24px;height:24px;border-radius:50%;border:3px solid white;box-shadow:0 2px 8px rgba(0,0,0,0.4);${fields.Statut === 'Resolu' ? 'opacity:0.5;' : ''}"></div>`,
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    });
                    const marker = L.marker([fields.Latitude, fields.Longitude], { icon }).bindPopup(popupContent).addTo(map);
                    existingMarkers.push(marker);
                }
            });
        }

        // --- [code inchang√© jusqu‚Äô√† getRouteInfo()] ---

        // ‚úÖ Nouvelle version avec Nominatim + Overpass en secours
        async function getRouteInfo(lat, lng) {
            let routeInfo = { route: '', commune: '' };
            try {
                // 1Ô∏è‚É£ Nominatim (OpenStreetMap)
                const response1 = await fetch(
                    `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1&extratags=1`,
                    { headers: { 'User-Agent': 'Widget-Grist-Routes/1.0' } }
                );
                const data1 = await response1.json();

                if (data1.address) {
                    routeInfo.commune = data1.address.city || data1.address.town || data1.address.village || '';
                    routeInfo.route = data1.address.road || '';
                }
                if (data1.extratags && data1.extratags.ref) {
                    routeInfo.route = data1.extratags.ref;
                }

                // 2Ô∏è‚É£ Si toujours pas de route trouv√©e ‚Üí Overpass (plan B)
                if (!routeInfo.route) {
                    const overpassQuery = `
                        [out:json];
                        way(around:50,${lat},${lng})["highway"~"^(motorway|trunk|primary|secondary)$"]["ref"];
                        out tags;
                    `;
                    const response2 = await fetch("https://overpass-api.de/api/interpreter", {
                        method: "POST",
                        body: overpassQuery
                    });
                    const data2 = await response2.json();
                    if (data2.elements && data2.elements.length > 0) {
                        const road = data2.elements[0];
                        if (road.tags && road.tags.ref) {
                            routeInfo.route = road.tags.ref;
                        }
                    }
                }
            } catch (error) {
                console.error('Erreur r√©cup√©ration route:', error);
            }
            return routeInfo;
        }

        // --- le reste du code (showFormPopup, submitSignalement, etc.) reste inchang√© ---
        setTimeout(initMap, 1000);
    </script>
</body>
</html>
